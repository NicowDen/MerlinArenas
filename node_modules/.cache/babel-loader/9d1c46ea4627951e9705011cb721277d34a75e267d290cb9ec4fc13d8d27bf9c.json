{"ast":null,"code":"// import mc from \"./fight-scene.module.scss\";\n// import { useDispatch, useSelector } from \"react-redux\";\n// import { useEffect, useState } from \"react\";\n// //components//\n// import LifeBar from \"../fight-scene-elements/life-bar/LifeBar\";\n// import MdjScene from \"../fight-scene-elements/mdj-scene/MdjScene\";\n// import Fight from \"../fight-scene-elements/fight/Fight\";\n// import Tv from \"../fight-scene-elements/tv/Tv\";\n// import Tutoriel from \"../fight-scene-elements/tutoriel/Tutoriel\";\n// //utils//\n// import { getRandom } from \"../../utils/getRandom\";\n// //MDJ dialogs//\n// import {\n//   mdjWelcomeString,\n//   mdjTauntAttacker,\n//   mdjTauntDefender,\n//   mdjFightWillStart,\n//   mdjPotionOk,\n//   mdjPotionNok,\n//   mdjNoMorePotion,\n//   mdjDefense,\n// } from \"../../constants/mdj\";\n\n// const FightScene = () => {\n//   const dispatch = useDispatch();\n\n//   const {\n//     windowWidth,\n//     player1,\n//     player2,\n//     tutoriel,\n//     animationTutoriel,\n//     logs,\n//     playersClickOnstartGame,\n//     startTv,\n//     round,\n//     dice,\n//     attacker,\n//     defender,\n//     playerActionStatus,\n//     canPlay,\n//   } = useSelector((store) => {\n//     return {\n//       player1: store.playersReducer.player1,\n//       player2: store.playersReducer.player2,\n//       windowWidth: store.windowSizeReducer.windowWidth,\n//       tutoriel: store.fightReducer.tutoriel,\n//       animationTutoriel: store.animationsReducer.animationTutoriel,\n//       logs: store.fightReducer.logs,\n//       playersClickOnstartGame: store.fightReducer.playersClickOnstartGame,\n//       startTv: store.fightReducer.startTv,\n//       round: store.fightReducer.round,\n//       dice: store.fightReducer.dice,\n//       attacker: store.fightReducer.attacker,\n//       defender: store.fightReducer.defender,\n//       playerActionStatus: store.fightReducer.playerActionStatus,\n//       canPlay: store.fightReducer.canPlay,\n//     };\n//   });\n\n//   // const resetLogs = () => {\n//   //   dispatch({ type: \"RESET_LOGS\" });\n//   // };\n//   // useEffect(() => {\n//   //   dispatch({ type: \"RESET_LOGS\" });\n//   // }, []);\n\n//   // Fight end\n//   const onEndFightButtonClick = () => {\n//     dispatch({ type: `ANIMATION_FIGHT_START_CANCEL` });\n//     setTimeout(() => {\n//       dispatch({ type: `FIGHT_END` });\n//     }, 300);\n//   };\n\n//   //mdj dialogs states rdm//\n//   // const [randomNWelcomeMdj, setRandomNWelcomeMdj] = useState(null);\n//   // const [randomNmdjTauntDefender, setRandomNmdjTauntDefender] = useState(null);\n//   // const [randomNmdjTauntAttacker, setRandomNmdjTauntAttacker] = useState(null);\n//   // const [randomNmdjPotionOk, setRandomNmdjPotionOk] = useState(null);\n//   // const [randomNmdjPotionNok, setRandomNmdjPotionNok] = useState(null);\n//   // const [randomNmdjPotionZero, setRandomNmdjPotionZero] = useState(null);\n//   // const [randomNmdjPlayerDefense, setRandomNmdjPlayerDefense] = useState(null);\n\n//   const [random, setRandom] = useState(null);\n\n//   const closeTutoriel = () => {\n//     dispatch({\n//       type: \"ANIMATION_CLOSE_TUTORIEL_START\",\n//     });\n//     // setRandomNWelcomeMdj(getRandom(0, 1));\n//     setRandom(getRandom(0, 1));\n//     setTimeout(() => {\n//       dispatch({ type: \"CLOSE_TUTORIEL\" });\n//     }, 400);\n//   };\n\n//   const startGame = () => {\n//     dispatch({ type: \"START_TV\" });\n//     setTimeout(() => {\n//       dispatch({ type: \"LAUNCH_FIGHT\" });\n//       //get 1 or 2 and determine who play first and all the game long.\n//       dispatch({\n//         type: \"UPDATE_ROUND\",\n//         payload: { round: getRandom(1, 2) },\n//       });\n//     }, 500);\n//   };\n\n//   //after each players action round change//\n//   const newRound = (nbRoundAdd) => {\n//     dispatch({ type: \"CANT_PLAY\" });\n//     setTimeout(() => {\n//       dispatch({\n//         type: \"UPDATE_ROUND\",\n//         payload: { round: round + nbRoundAdd },\n//       });\n//       dispatch({ type: \"CAN_PLAY\" });\n//     }, 2500);\n//   };\n\n//   //DICE 20 value change//\n//   const newDice = () => {\n//     dispatch({\n//       type: \"UPDATE_DICE\",\n//       payload: { value: getRandom(1, 20) },\n//     });\n//   };\n\n//   //in combat log on the bottom of the screen//\n//   const newLog = (string) => {\n//     dispatch({\n//       type: \"UPDATE_LOGS\",\n//       payload: {\n//         newlog: string,\n//       },\n//     });\n//   };\n\n//   //to define attacker and defender variables for some conditions =\"player1\" or \"player2\"  //\n//   const attackerDefenderStrings = (attacker, defender) => {\n//     dispatch({\n//       type: \"UPDATE_ATTACKER\",\n//       payload: { attacker },\n//     });\n//     dispatch({\n//       type: \"UPDATE_DEFENDER\",\n//       payload: { defender },\n//     });\n//   };\n\n//   //defender dodge chance//\n//   const dodge = (defender) => {\n//     return dice.value < defender.playerClass.agi ? true : false;\n//   };\n\n//   //round is even or odd, so modulo2 to determine who can play. If round is odd player 1, else player 2\n//   //for each action we add 1 to round. No just change for 1 or 2. We need this way for capacities Cooldown.\n\n//   //===SKILLS====//\n//   //ATTACK SKILL//\n//   const basicAttackDmg = (attacker, defender, defenderTostring) => {\n//     // setRandomNmdjTauntDefender(getRandom(0, 3));\n//     // setRandomNmdjTauntAttacker(0, 3);\n//     setRandom(getRandom(0, 3));\n//     const dmg = Math.round(\n//       ((attacker.playerClass.atk / 2) * attacker.playerClass.spd) / 100 +\n//         attacker.playerClass.int / 9.5 +\n//         getRandom(1, 8) +\n//         getRandom(1, 8) -\n//         defender.playerClass.armor / 2\n//     );\n//     if (dodge(defender)) {\n//       dispatch({\n//         type: \"PLAYER_TAKE_DMG\",\n//         payload: { player: defenderTostring, hitValue: 0 },\n//       });\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_FAIL\" });\n//       newLog(`${defender.pseudo.toUpperCase()} esquive`);\n//       newRound(1);\n//       newDice();\n//     } else {\n//       dispatch({\n//         type: \"PLAYER_TAKE_DMG\",\n//         payload: { player: defenderTostring, hitValue: dmg },\n//       });\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_HIT\" });\n//       newLog(\n//         `${attacker.pseudo.toUpperCase()} inflige ${dmg} points de dégâts à ${\n//           defender.pseudo\n//         }`\n//       );\n//       newRound(1);\n//       newDice();\n//     }\n//   };\n//   const onAttackClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//       basicAttackDmg(player1, player2, \"player2\");\n//     }\n//   };\n//   const onAttackClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//       basicAttackDmg(player2, player1, \"player1\");\n//     }\n//   };\n\n//   console.log(player1);\n//   //DEFENSE SKILL//\n//   const defenseCounterAttack = (attackerToString) => {\n//     dispatch({\n//       type: \"PLAYER_DEFENSE_UP\",\n//       payload: { player: attackerToString },\n//     });\n//     dispatch({ type: \"PLAYER_ACTION_STATUS_DEFENSE\" });\n//     // setRandomNmdjPlayerDefense(getRandom(0, 2));\n//     // setRandom(getRandom(0, 2));\n//     setRandom(getRandom(0, 2));\n//   };\n//   const onDefenseClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//       defenseCounterAttack(\"player1\");\n//     }\n//   };\n//   const onDefenseClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//       defenseCounterAttack(\"player2\");\n//     }\n//   };\n\n//   //ULTIM SKILL//\n//   const onUltimClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//     }\n//   };\n//   const onUltimClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//     }\n//   };\n\n//   //POTION SKILL//\n//   const potionHeal = (attacker, attackerTostring) => {\n//     if (attacker.playerClass.hp >= 300) {\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_POTION_NOK\" });\n//       // setRandomNmdjPotionNok(getRandom(0, 2));\n//       setRandom(getRandom(0, 2));\n//       newDice();\n//     } else if (attacker.playerClass.potions <= 0) {\n//       // setRandomNmdjPotionZero(getRandom(0, 2));\n//       setRandom(getRandom(0, 2));\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_POTION_ZERO\" });\n//       newDice();\n//     } else {\n//       dispatch({\n//         type: \"PLAYER_POTION_HEAL\",\n//         payload: { player: attackerTostring },\n//       });\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_POTION_OK\" });\n//       // setRandomNmdjPotionOk(getRandom(0, 2));\n//       setRandom(getRandom(0, 2));\n//       newRound(1);\n//       newDice();\n//     }\n//   };\n//   const onPotionClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//       potionHeal(player1, \"player1\");\n//     }\n//   };\n//   const onPotionClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//       potionHeal(player2, \"player2\");\n//     }\n//   };\n\n//   return (\n//     <>\n//       {tutoriel && (\n//         <div className={mc.tutoriel}>\n//           <Tutoriel\n//             player1={player1}\n//             player2={player2}\n//             closeTutoriel={closeTutoriel}\n//             animation={animationTutoriel}\n//           />\n//         </div>\n//       )}\n//       <div className={mc.container}>\n//         <div className={mc.fightingZone_zone}>\n//           <div className={mc.top_menu}>\n//             <div className={mc.life_bars_player1}>\n//               <LifeBar\n//                 windowWidth={windowWidth}\n//                 playerNumber={1} //determine row-reverse for player1\n//                 player={player1}\n//               />\n//             </div>\n//             <div className={mc.top_tv}>\n//               <button onClick={startGame}>Clique ici pour commencer</button>\n//               <div\n//                 className={\n//                   startTv ? `${mc.clean_tv} ${mc.clean_tv_on}` : mc.clean_tv\n//                 }\n//               ></div>\n//               {playersClickOnstartGame && (\n//                 <div className={mc.myTV}>\n//                   <Tv round={round} player1={player1} player2={player2} />\n//                 </div>\n//               )}\n//             </div>\n\n//             <div className={mc.life_bars_player2}>\n//               <LifeBar\n//                 windowWidth={windowWidth}\n//                 playerNumber={2} //determine row-reverse for player2\n//                 player={player2}\n//               />\n//             </div>\n//           </div>\n//           <div className={mc.mdj_menu}>\n//             <MdjScene\n//               player1={player1}\n//               player2={player2}\n//               attacker={attacker === \"player1\" ? player1 : player2}\n//               defender={defender === \"player1\" ? player1 : player2}\n//               string={\n//                 !playersClickOnstartGame && random !== null\n//                   ? mdjWelcomeString[random]\n//                   : playersClickOnstartGame && playerActionStatus === \"\"\n//                   ? mdjFightWillStart\n//                   : playersClickOnstartGame && playerActionStatus === \"hit\"\n//                   ? mdjTauntDefender[random]\n//                   : playersClickOnstartGame && playerActionStatus === \"fail\"\n//                   ? mdjTauntAttacker[random]\n//                   : playersClickOnstartGame && playerActionStatus === \"potionOk\"\n//                   ? mdjPotionOk[random]\n//                   : playersClickOnstartGame &&\n//                     playerActionStatus === \"potionNok\"\n//                   ? mdjPotionNok[random]\n//                   : playersClickOnstartGame &&\n//                     playerActionStatus === \"potionZero\"\n//                   ? mdjNoMorePotion[random]\n//                   : playerActionStatus === \"defense\"\n//                   ? mdjDefense[random]\n//                   : \"\"\n//               }\n//               playerActionStatus={playerActionStatus}\n//             />\n//           </div>\n//           <div className={mc.fighting_menu}>\n//             <Fight\n//               windowWidth={windowWidth}\n//               player1={player1}\n//               player2={player2}\n//               logs={logs}\n//               onAttackClickP1={onAttackClickP1}\n//               onDefenseClickP1={onDefenseClickP1}\n//               onUltimClickP1={onUltimClickP1}\n//               onPotionClickP1={onPotionClickP1}\n//               onAttackClickP2={onAttackClickP2}\n//               onDefenseClickP2={onDefenseClickP2}\n//               onUltimClickP2={onUltimClickP2}\n//               onPotionClickP2={onPotionClickP2}\n//               round={round}\n//               attacker={attacker}\n//               playerActionStatus={playerActionStatus}\n//             />\n//           </div>\n//         </div>\n//       </div>\n//     </>\n//   );\n// };\n\n// export default FightScene;","map":{"version":3,"names":[],"sources":["/Users/nicolasgrenier/Documents/Code/fighting_RPG/src/components/fight-scene/FightScene.jsx"],"sourcesContent":["// import mc from \"./fight-scene.module.scss\";\n// import { useDispatch, useSelector } from \"react-redux\";\n// import { useEffect, useState } from \"react\";\n// //components//\n// import LifeBar from \"../fight-scene-elements/life-bar/LifeBar\";\n// import MdjScene from \"../fight-scene-elements/mdj-scene/MdjScene\";\n// import Fight from \"../fight-scene-elements/fight/Fight\";\n// import Tv from \"../fight-scene-elements/tv/Tv\";\n// import Tutoriel from \"../fight-scene-elements/tutoriel/Tutoriel\";\n// //utils//\n// import { getRandom } from \"../../utils/getRandom\";\n// //MDJ dialogs//\n// import {\n//   mdjWelcomeString,\n//   mdjTauntAttacker,\n//   mdjTauntDefender,\n//   mdjFightWillStart,\n//   mdjPotionOk,\n//   mdjPotionNok,\n//   mdjNoMorePotion,\n//   mdjDefense,\n// } from \"../../constants/mdj\";\n\n// const FightScene = () => {\n//   const dispatch = useDispatch();\n\n//   const {\n//     windowWidth,\n//     player1,\n//     player2,\n//     tutoriel,\n//     animationTutoriel,\n//     logs,\n//     playersClickOnstartGame,\n//     startTv,\n//     round,\n//     dice,\n//     attacker,\n//     defender,\n//     playerActionStatus,\n//     canPlay,\n//   } = useSelector((store) => {\n//     return {\n//       player1: store.playersReducer.player1,\n//       player2: store.playersReducer.player2,\n//       windowWidth: store.windowSizeReducer.windowWidth,\n//       tutoriel: store.fightReducer.tutoriel,\n//       animationTutoriel: store.animationsReducer.animationTutoriel,\n//       logs: store.fightReducer.logs,\n//       playersClickOnstartGame: store.fightReducer.playersClickOnstartGame,\n//       startTv: store.fightReducer.startTv,\n//       round: store.fightReducer.round,\n//       dice: store.fightReducer.dice,\n//       attacker: store.fightReducer.attacker,\n//       defender: store.fightReducer.defender,\n//       playerActionStatus: store.fightReducer.playerActionStatus,\n//       canPlay: store.fightReducer.canPlay,\n//     };\n//   });\n\n//   // const resetLogs = () => {\n//   //   dispatch({ type: \"RESET_LOGS\" });\n//   // };\n//   // useEffect(() => {\n//   //   dispatch({ type: \"RESET_LOGS\" });\n//   // }, []);\n\n//   // Fight end\n//   const onEndFightButtonClick = () => {\n//     dispatch({ type: `ANIMATION_FIGHT_START_CANCEL` });\n//     setTimeout(() => {\n//       dispatch({ type: `FIGHT_END` });\n//     }, 300);\n//   };\n\n//   //mdj dialogs states rdm//\n//   // const [randomNWelcomeMdj, setRandomNWelcomeMdj] = useState(null);\n//   // const [randomNmdjTauntDefender, setRandomNmdjTauntDefender] = useState(null);\n//   // const [randomNmdjTauntAttacker, setRandomNmdjTauntAttacker] = useState(null);\n//   // const [randomNmdjPotionOk, setRandomNmdjPotionOk] = useState(null);\n//   // const [randomNmdjPotionNok, setRandomNmdjPotionNok] = useState(null);\n//   // const [randomNmdjPotionZero, setRandomNmdjPotionZero] = useState(null);\n//   // const [randomNmdjPlayerDefense, setRandomNmdjPlayerDefense] = useState(null);\n\n//   const [random, setRandom] = useState(null);\n\n//   const closeTutoriel = () => {\n//     dispatch({\n//       type: \"ANIMATION_CLOSE_TUTORIEL_START\",\n//     });\n//     // setRandomNWelcomeMdj(getRandom(0, 1));\n//     setRandom(getRandom(0, 1));\n//     setTimeout(() => {\n//       dispatch({ type: \"CLOSE_TUTORIEL\" });\n//     }, 400);\n//   };\n\n//   const startGame = () => {\n//     dispatch({ type: \"START_TV\" });\n//     setTimeout(() => {\n//       dispatch({ type: \"LAUNCH_FIGHT\" });\n//       //get 1 or 2 and determine who play first and all the game long.\n//       dispatch({\n//         type: \"UPDATE_ROUND\",\n//         payload: { round: getRandom(1, 2) },\n//       });\n//     }, 500);\n//   };\n\n//   //after each players action round change//\n//   const newRound = (nbRoundAdd) => {\n//     dispatch({ type: \"CANT_PLAY\" });\n//     setTimeout(() => {\n//       dispatch({\n//         type: \"UPDATE_ROUND\",\n//         payload: { round: round + nbRoundAdd },\n//       });\n//       dispatch({ type: \"CAN_PLAY\" });\n//     }, 2500);\n//   };\n\n//   //DICE 20 value change//\n//   const newDice = () => {\n//     dispatch({\n//       type: \"UPDATE_DICE\",\n//       payload: { value: getRandom(1, 20) },\n//     });\n//   };\n\n//   //in combat log on the bottom of the screen//\n//   const newLog = (string) => {\n//     dispatch({\n//       type: \"UPDATE_LOGS\",\n//       payload: {\n//         newlog: string,\n//       },\n//     });\n//   };\n\n//   //to define attacker and defender variables for some conditions =\"player1\" or \"player2\"  //\n//   const attackerDefenderStrings = (attacker, defender) => {\n//     dispatch({\n//       type: \"UPDATE_ATTACKER\",\n//       payload: { attacker },\n//     });\n//     dispatch({\n//       type: \"UPDATE_DEFENDER\",\n//       payload: { defender },\n//     });\n//   };\n\n//   //defender dodge chance//\n//   const dodge = (defender) => {\n//     return dice.value < defender.playerClass.agi ? true : false;\n//   };\n\n//   //round is even or odd, so modulo2 to determine who can play. If round is odd player 1, else player 2\n//   //for each action we add 1 to round. No just change for 1 or 2. We need this way for capacities Cooldown.\n\n//   //===SKILLS====//\n//   //ATTACK SKILL//\n//   const basicAttackDmg = (attacker, defender, defenderTostring) => {\n//     // setRandomNmdjTauntDefender(getRandom(0, 3));\n//     // setRandomNmdjTauntAttacker(0, 3);\n//     setRandom(getRandom(0, 3));\n//     const dmg = Math.round(\n//       ((attacker.playerClass.atk / 2) * attacker.playerClass.spd) / 100 +\n//         attacker.playerClass.int / 9.5 +\n//         getRandom(1, 8) +\n//         getRandom(1, 8) -\n//         defender.playerClass.armor / 2\n//     );\n//     if (dodge(defender)) {\n//       dispatch({\n//         type: \"PLAYER_TAKE_DMG\",\n//         payload: { player: defenderTostring, hitValue: 0 },\n//       });\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_FAIL\" });\n//       newLog(`${defender.pseudo.toUpperCase()} esquive`);\n//       newRound(1);\n//       newDice();\n//     } else {\n//       dispatch({\n//         type: \"PLAYER_TAKE_DMG\",\n//         payload: { player: defenderTostring, hitValue: dmg },\n//       });\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_HIT\" });\n//       newLog(\n//         `${attacker.pseudo.toUpperCase()} inflige ${dmg} points de dégâts à ${\n//           defender.pseudo\n//         }`\n//       );\n//       newRound(1);\n//       newDice();\n//     }\n//   };\n//   const onAttackClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//       basicAttackDmg(player1, player2, \"player2\");\n//     }\n//   };\n//   const onAttackClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//       basicAttackDmg(player2, player1, \"player1\");\n//     }\n//   };\n\n//   console.log(player1);\n//   //DEFENSE SKILL//\n//   const defenseCounterAttack = (attackerToString) => {\n//     dispatch({\n//       type: \"PLAYER_DEFENSE_UP\",\n//       payload: { player: attackerToString },\n//     });\n//     dispatch({ type: \"PLAYER_ACTION_STATUS_DEFENSE\" });\n//     // setRandomNmdjPlayerDefense(getRandom(0, 2));\n//     // setRandom(getRandom(0, 2));\n//     setRandom(getRandom(0, 2));\n//   };\n//   const onDefenseClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//       defenseCounterAttack(\"player1\");\n//     }\n//   };\n//   const onDefenseClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//       defenseCounterAttack(\"player2\");\n//     }\n//   };\n\n//   //ULTIM SKILL//\n//   const onUltimClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//     }\n//   };\n//   const onUltimClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//     }\n//   };\n\n//   //POTION SKILL//\n//   const potionHeal = (attacker, attackerTostring) => {\n//     if (attacker.playerClass.hp >= 300) {\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_POTION_NOK\" });\n//       // setRandomNmdjPotionNok(getRandom(0, 2));\n//       setRandom(getRandom(0, 2));\n//       newDice();\n//     } else if (attacker.playerClass.potions <= 0) {\n//       // setRandomNmdjPotionZero(getRandom(0, 2));\n//       setRandom(getRandom(0, 2));\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_POTION_ZERO\" });\n//       newDice();\n//     } else {\n//       dispatch({\n//         type: \"PLAYER_POTION_HEAL\",\n//         payload: { player: attackerTostring },\n//       });\n//       dispatch({ type: \"PLAYER_ACTION_STATUS_POTION_OK\" });\n//       // setRandomNmdjPotionOk(getRandom(0, 2));\n//       setRandom(getRandom(0, 2));\n//       newRound(1);\n//       newDice();\n//     }\n//   };\n//   const onPotionClickP1 = () => {\n//     if (round % 2 === 1 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player1\", \"player2\");\n//       potionHeal(player1, \"player1\");\n//     }\n//   };\n//   const onPotionClickP2 = () => {\n//     if (round % 2 === 0 && round > 0 && canPlay) {\n//       attackerDefenderStrings(\"player2\", \"player1\");\n//       potionHeal(player2, \"player2\");\n//     }\n//   };\n\n//   return (\n//     <>\n//       {tutoriel && (\n//         <div className={mc.tutoriel}>\n//           <Tutoriel\n//             player1={player1}\n//             player2={player2}\n//             closeTutoriel={closeTutoriel}\n//             animation={animationTutoriel}\n//           />\n//         </div>\n//       )}\n//       <div className={mc.container}>\n//         <div className={mc.fightingZone_zone}>\n//           <div className={mc.top_menu}>\n//             <div className={mc.life_bars_player1}>\n//               <LifeBar\n//                 windowWidth={windowWidth}\n//                 playerNumber={1} //determine row-reverse for player1\n//                 player={player1}\n//               />\n//             </div>\n//             <div className={mc.top_tv}>\n//               <button onClick={startGame}>Clique ici pour commencer</button>\n//               <div\n//                 className={\n//                   startTv ? `${mc.clean_tv} ${mc.clean_tv_on}` : mc.clean_tv\n//                 }\n//               ></div>\n//               {playersClickOnstartGame && (\n//                 <div className={mc.myTV}>\n//                   <Tv round={round} player1={player1} player2={player2} />\n//                 </div>\n//               )}\n//             </div>\n\n//             <div className={mc.life_bars_player2}>\n//               <LifeBar\n//                 windowWidth={windowWidth}\n//                 playerNumber={2} //determine row-reverse for player2\n//                 player={player2}\n//               />\n//             </div>\n//           </div>\n//           <div className={mc.mdj_menu}>\n//             <MdjScene\n//               player1={player1}\n//               player2={player2}\n//               attacker={attacker === \"player1\" ? player1 : player2}\n//               defender={defender === \"player1\" ? player1 : player2}\n//               string={\n//                 !playersClickOnstartGame && random !== null\n//                   ? mdjWelcomeString[random]\n//                   : playersClickOnstartGame && playerActionStatus === \"\"\n//                   ? mdjFightWillStart\n//                   : playersClickOnstartGame && playerActionStatus === \"hit\"\n//                   ? mdjTauntDefender[random]\n//                   : playersClickOnstartGame && playerActionStatus === \"fail\"\n//                   ? mdjTauntAttacker[random]\n//                   : playersClickOnstartGame && playerActionStatus === \"potionOk\"\n//                   ? mdjPotionOk[random]\n//                   : playersClickOnstartGame &&\n//                     playerActionStatus === \"potionNok\"\n//                   ? mdjPotionNok[random]\n//                   : playersClickOnstartGame &&\n//                     playerActionStatus === \"potionZero\"\n//                   ? mdjNoMorePotion[random]\n//                   : playerActionStatus === \"defense\"\n//                   ? mdjDefense[random]\n//                   : \"\"\n//               }\n//               playerActionStatus={playerActionStatus}\n//             />\n//           </div>\n//           <div className={mc.fighting_menu}>\n//             <Fight\n//               windowWidth={windowWidth}\n//               player1={player1}\n//               player2={player2}\n//               logs={logs}\n//               onAttackClickP1={onAttackClickP1}\n//               onDefenseClickP1={onDefenseClickP1}\n//               onUltimClickP1={onUltimClickP1}\n//               onPotionClickP1={onPotionClickP1}\n//               onAttackClickP2={onAttackClickP2}\n//               onDefenseClickP2={onDefenseClickP2}\n//               onUltimClickP2={onUltimClickP2}\n//               onPotionClickP2={onPotionClickP2}\n//               round={round}\n//               attacker={attacker}\n//               playerActionStatus={playerActionStatus}\n//             />\n//           </div>\n//         </div>\n//       </div>\n//     </>\n//   );\n// };\n\n// export default FightScene;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}