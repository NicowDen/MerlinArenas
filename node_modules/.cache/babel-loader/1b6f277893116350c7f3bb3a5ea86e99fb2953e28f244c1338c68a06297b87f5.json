{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Kaleidoscope = void 0;\nconst Factory_1 = require(\"../Factory\");\nconst Node_1 = require(\"../Node\");\nconst Util_1 = require(\"../Util\");\nconst Validators_1 = require(\"../Validators\");\nvar ToPolar = function (src, dst, opt) {\n  var srcPixels = src.data,\n    dstPixels = dst.data,\n    xSize = src.width,\n    ySize = src.height,\n    xMid = opt.polarCenterX || xSize / 2,\n    yMid = opt.polarCenterY || ySize / 2,\n    i,\n    x,\n    y,\n    r = 0,\n    g = 0,\n    b = 0,\n    a = 0;\n  var rad,\n    rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n  x = xSize - xMid;\n  y = ySize - yMid;\n  rad = Math.sqrt(x * x + y * y);\n  rMax = rad > rMax ? rad : rMax;\n  var rSize = ySize,\n    tSize = xSize,\n    radius,\n    theta;\n  var conversion = 360 / tSize * Math.PI / 180,\n    sin,\n    cos;\n  for (theta = 0; theta < tSize; theta += 1) {\n    sin = Math.sin(theta * conversion);\n    cos = Math.cos(theta * conversion);\n    for (radius = 0; radius < rSize; radius += 1) {\n      x = Math.floor(xMid + rMax * radius / rSize * cos);\n      y = Math.floor(yMid + rMax * radius / rSize * sin);\n      i = (y * xSize + x) * 4;\n      r = srcPixels[i + 0];\n      g = srcPixels[i + 1];\n      b = srcPixels[i + 2];\n      a = srcPixels[i + 3];\n      i = (theta + radius * xSize) * 4;\n      dstPixels[i + 0] = r;\n      dstPixels[i + 1] = g;\n      dstPixels[i + 2] = b;\n      dstPixels[i + 3] = a;\n    }\n  }\n};\nvar FromPolar = function (src, dst, opt) {\n  var srcPixels = src.data,\n    dstPixels = dst.data,\n    xSize = src.width,\n    ySize = src.height,\n    xMid = opt.polarCenterX || xSize / 2,\n    yMid = opt.polarCenterY || ySize / 2,\n    i,\n    x,\n    y,\n    dx,\n    dy,\n    r = 0,\n    g = 0,\n    b = 0,\n    a = 0;\n  var rad,\n    rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n  x = xSize - xMid;\n  y = ySize - yMid;\n  rad = Math.sqrt(x * x + y * y);\n  rMax = rad > rMax ? rad : rMax;\n  var rSize = ySize,\n    tSize = xSize,\n    radius,\n    theta,\n    phaseShift = opt.polarRotation || 0;\n  var x1, y1;\n  for (x = 0; x < xSize; x += 1) {\n    for (y = 0; y < ySize; y += 1) {\n      dx = x - xMid;\n      dy = y - yMid;\n      radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;\n      theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;\n      theta = theta * tSize / 360;\n      x1 = Math.floor(theta);\n      y1 = Math.floor(radius);\n      i = (y1 * xSize + x1) * 4;\n      r = srcPixels[i + 0];\n      g = srcPixels[i + 1];\n      b = srcPixels[i + 2];\n      a = srcPixels[i + 3];\n      i = (y * xSize + x) * 4;\n      dstPixels[i + 0] = r;\n      dstPixels[i + 1] = g;\n      dstPixels[i + 2] = b;\n      dstPixels[i + 3] = a;\n    }\n  }\n};\nconst Kaleidoscope = function (imageData) {\n  var xSize = imageData.width,\n    ySize = imageData.height;\n  var x, y, xoff, i, r, g, b, a, srcPos, dstPos;\n  var power = Math.round(this.kaleidoscopePower());\n  var angle = Math.round(this.kaleidoscopeAngle());\n  var offset = Math.floor(xSize * (angle % 360) / 360);\n  if (power < 1) {\n    return;\n  }\n  var tempCanvas = Util_1.Util.createCanvasElement();\n  tempCanvas.width = xSize;\n  tempCanvas.height = ySize;\n  var scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);\n  Util_1.Util.releaseCanvas(tempCanvas);\n  ToPolar(imageData, scratchData, {\n    polarCenterX: xSize / 2,\n    polarCenterY: ySize / 2\n  });\n  var minSectionSize = xSize / Math.pow(2, power);\n  while (minSectionSize <= 8) {\n    minSectionSize = minSectionSize * 2;\n    power -= 1;\n  }\n  minSectionSize = Math.ceil(minSectionSize);\n  var sectionSize = minSectionSize;\n  var xStart = 0,\n    xEnd = sectionSize,\n    xDelta = 1;\n  if (offset + minSectionSize > xSize) {\n    xStart = sectionSize;\n    xEnd = 0;\n    xDelta = -1;\n  }\n  for (y = 0; y < ySize; y += 1) {\n    for (x = xStart; x !== xEnd; x += xDelta) {\n      xoff = Math.round(x + offset) % xSize;\n      srcPos = (xSize * y + xoff) * 4;\n      r = scratchData.data[srcPos + 0];\n      g = scratchData.data[srcPos + 1];\n      b = scratchData.data[srcPos + 2];\n      a = scratchData.data[srcPos + 3];\n      dstPos = (xSize * y + x) * 4;\n      scratchData.data[dstPos + 0] = r;\n      scratchData.data[dstPos + 1] = g;\n      scratchData.data[dstPos + 2] = b;\n      scratchData.data[dstPos + 3] = a;\n    }\n  }\n  for (y = 0; y < ySize; y += 1) {\n    sectionSize = Math.floor(minSectionSize);\n    for (i = 0; i < power; i += 1) {\n      for (x = 0; x < sectionSize + 1; x += 1) {\n        srcPos = (xSize * y + x) * 4;\n        r = scratchData.data[srcPos + 0];\n        g = scratchData.data[srcPos + 1];\n        b = scratchData.data[srcPos + 2];\n        a = scratchData.data[srcPos + 3];\n        dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;\n        scratchData.data[dstPos + 0] = r;\n        scratchData.data[dstPos + 1] = g;\n        scratchData.data[dstPos + 2] = b;\n        scratchData.data[dstPos + 3] = a;\n      }\n      sectionSize *= 2;\n    }\n  }\n  FromPolar(scratchData, imageData, {\n    polarRotation: 0\n  });\n};\nexports.Kaleidoscope = Kaleidoscope;\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopePower', 2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopeAngle', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);","map":{"version":3,"names":["Object","defineProperty","exports","value","Kaleidoscope","Factory_1","require","Node_1","Util_1","Validators_1","ToPolar","src","dst","opt","srcPixels","data","dstPixels","xSize","width","ySize","height","xMid","polarCenterX","yMid","polarCenterY","i","x","y","r","g","b","a","rad","rMax","Math","sqrt","rSize","tSize","radius","theta","conversion","PI","sin","cos","floor","FromPolar","dx","dy","phaseShift","polarRotation","x1","y1","atan2","imageData","xoff","srcPos","dstPos","power","round","kaleidoscopePower","angle","kaleidoscopeAngle","offset","tempCanvas","Util","createCanvasElement","scratchData","getContext","getImageData","releaseCanvas","minSectionSize","pow","ceil","sectionSize","xStart","xEnd","xDelta","Factory","addGetterSetter","Node","getNumberValidator","afterSetFilter"],"sources":["/Users/nicolasgrenier/Documents/Code/fighting_RPG/node_modules/konva/lib/filters/Kaleidoscope.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Kaleidoscope = void 0;\nconst Factory_1 = require(\"../Factory\");\nconst Node_1 = require(\"../Node\");\nconst Util_1 = require(\"../Util\");\nconst Validators_1 = require(\"../Validators\");\nvar ToPolar = function (src, dst, opt) {\n    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0;\n    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n    x = xSize - xMid;\n    y = ySize - yMid;\n    rad = Math.sqrt(x * x + y * y);\n    rMax = rad > rMax ? rad : rMax;\n    var rSize = ySize, tSize = xSize, radius, theta;\n    var conversion = ((360 / tSize) * Math.PI) / 180, sin, cos;\n    for (theta = 0; theta < tSize; theta += 1) {\n        sin = Math.sin(theta * conversion);\n        cos = Math.cos(theta * conversion);\n        for (radius = 0; radius < rSize; radius += 1) {\n            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);\n            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);\n            i = (y * xSize + x) * 4;\n            r = srcPixels[i + 0];\n            g = srcPixels[i + 1];\n            b = srcPixels[i + 2];\n            a = srcPixels[i + 3];\n            i = (theta + radius * xSize) * 4;\n            dstPixels[i + 0] = r;\n            dstPixels[i + 1] = g;\n            dstPixels[i + 2] = b;\n            dstPixels[i + 3] = a;\n        }\n    }\n};\nvar FromPolar = function (src, dst, opt) {\n    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;\n    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);\n    x = xSize - xMid;\n    y = ySize - yMid;\n    rad = Math.sqrt(x * x + y * y);\n    rMax = rad > rMax ? rad : rMax;\n    var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0;\n    var x1, y1;\n    for (x = 0; x < xSize; x += 1) {\n        for (y = 0; y < ySize; y += 1) {\n            dx = x - xMid;\n            dy = y - yMid;\n            radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;\n            theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;\n            theta = (theta * tSize) / 360;\n            x1 = Math.floor(theta);\n            y1 = Math.floor(radius);\n            i = (y1 * xSize + x1) * 4;\n            r = srcPixels[i + 0];\n            g = srcPixels[i + 1];\n            b = srcPixels[i + 2];\n            a = srcPixels[i + 3];\n            i = (y * xSize + x) * 4;\n            dstPixels[i + 0] = r;\n            dstPixels[i + 1] = g;\n            dstPixels[i + 2] = b;\n            dstPixels[i + 3] = a;\n        }\n    }\n};\nconst Kaleidoscope = function (imageData) {\n    var xSize = imageData.width, ySize = imageData.height;\n    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;\n    var power = Math.round(this.kaleidoscopePower());\n    var angle = Math.round(this.kaleidoscopeAngle());\n    var offset = Math.floor((xSize * (angle % 360)) / 360);\n    if (power < 1) {\n        return;\n    }\n    var tempCanvas = Util_1.Util.createCanvasElement();\n    tempCanvas.width = xSize;\n    tempCanvas.height = ySize;\n    var scratchData = tempCanvas\n        .getContext('2d')\n        .getImageData(0, 0, xSize, ySize);\n    Util_1.Util.releaseCanvas(tempCanvas);\n    ToPolar(imageData, scratchData, {\n        polarCenterX: xSize / 2,\n        polarCenterY: ySize / 2,\n    });\n    var minSectionSize = xSize / Math.pow(2, power);\n    while (minSectionSize <= 8) {\n        minSectionSize = minSectionSize * 2;\n        power -= 1;\n    }\n    minSectionSize = Math.ceil(minSectionSize);\n    var sectionSize = minSectionSize;\n    var xStart = 0, xEnd = sectionSize, xDelta = 1;\n    if (offset + minSectionSize > xSize) {\n        xStart = sectionSize;\n        xEnd = 0;\n        xDelta = -1;\n    }\n    for (y = 0; y < ySize; y += 1) {\n        for (x = xStart; x !== xEnd; x += xDelta) {\n            xoff = Math.round(x + offset) % xSize;\n            srcPos = (xSize * y + xoff) * 4;\n            r = scratchData.data[srcPos + 0];\n            g = scratchData.data[srcPos + 1];\n            b = scratchData.data[srcPos + 2];\n            a = scratchData.data[srcPos + 3];\n            dstPos = (xSize * y + x) * 4;\n            scratchData.data[dstPos + 0] = r;\n            scratchData.data[dstPos + 1] = g;\n            scratchData.data[dstPos + 2] = b;\n            scratchData.data[dstPos + 3] = a;\n        }\n    }\n    for (y = 0; y < ySize; y += 1) {\n        sectionSize = Math.floor(minSectionSize);\n        for (i = 0; i < power; i += 1) {\n            for (x = 0; x < sectionSize + 1; x += 1) {\n                srcPos = (xSize * y + x) * 4;\n                r = scratchData.data[srcPos + 0];\n                g = scratchData.data[srcPos + 1];\n                b = scratchData.data[srcPos + 2];\n                a = scratchData.data[srcPos + 3];\n                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;\n                scratchData.data[dstPos + 0] = r;\n                scratchData.data[dstPos + 1] = g;\n                scratchData.data[dstPos + 2] = b;\n                scratchData.data[dstPos + 3] = a;\n            }\n            sectionSize *= 2;\n        }\n    }\n    FromPolar(scratchData, imageData, { polarRotation: 0 });\n};\nexports.Kaleidoscope = Kaleidoscope;\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopePower', 2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);\nFactory_1.Factory.addGetterSetter(Node_1.Node, 'kaleidoscopeAngle', 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}